package main

import (
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	root := "kitex_gen"

	// 1. General cleanup
	filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, ".go") {
			content, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			s := string(content)

			lines := strings.Split(s, "\n")
			var newLines []string
			for _, line := range lines {
				if strings.Contains(line, "code.byted.org/kitex/apache_monitor") {
					continue
				}
				if strings.Contains(line, "apache_warning.WarningApache") {
					continue
				}
				// Clean up internal imports if they remain
				if strings.Contains(line, "code.byted.org/kite/kitex/byted") {
					continue
				}

				// Replace imports
				line = strings.Replace(line, "code.byted.org/kite/kitex/client", "github.com/cloudwego/kitex/client", -1)
				line = strings.Replace(line, "code.byted.org/kite/kitex/server", "github.com/cloudwego/kitex/server", -1)

				newLines = append(newLines, line)
			}

			newContent := strings.Join(newLines, "\n")
			os.WriteFile(path, []byte(newContent), 0644)
		}
		return nil
	})

	// 2. Overwrite stock/stockservice/client.go
	stockClientContent := `// Code generated by Kitex v1.20.0. DO NOT EDIT.

package stockservice

import (
	"context"
	client "github.com/cloudwego/kitex/client"
	callopt "github.com/cloudwego/kitex/client/callopt"
	stock "stock_assistant/backend/stock_service/kitex_gen/stock"
)

// Client is designed to provide IDL-compatible methods with call-option parameter for kitex framework.
type Client interface {
	GetRealtime(ctx context.Context, req *stock.GetRealtimeRequest, callOptions ...callopt.Option) (r *stock.GetRealtimeResponse, err error)
	GetFinancialReport(ctx context.Context, req *stock.GetFinancialReportRequest, callOptions ...callopt.Option) (r *stock.GetFinancialReportResponse, err error)
	GetMarketSectors(ctx context.Context, req *stock.GetMarketSectorsRequest, callOptions ...callopt.Option) (r *stock.GetMarketSectorsResponse, err error)
	GetLimitUpPool(ctx context.Context, req *stock.GetLimitUpPoolRequest, callOptions ...callopt.Option) (r *stock.GetLimitUpPoolResponse, err error)
	GetSectorStocks(ctx context.Context, req *stock.GetSectorStocksRequest, callOptions ...callopt.Option) (r *stock.GetSectorStocksResponse, err error)
	GetDragonTigerList(ctx context.Context, req *stock.GetDragonTigerListRequest, callOptions ...callopt.Option) (r *stock.GetDragonTigerListResponse, err error)
}

// NewClient creates a client for the service defined in IDL.
func NewClient(destService string, opts ...client.Option) (Client, error) {
	var options []client.Option
	options = append(options, client.WithDestService(destService))

	options = append(options, opts...)

	kc, err := client.NewClient(serviceInfoForClient(), options...)
	if err != nil {
		return nil, err
	}
	return &kStockServiceClient{
		kClient: newServiceClient(kc),
	}, nil
}

// MustNewClient creates a client for the service defined in IDL. It panics if any error occurs.
func MustNewClient(destService string, opts ...client.Option) Client {
	kc, err := NewClient(destService, opts...)
	if err != nil {
		panic(err)
	}
	return kc
}

type kStockServiceClient struct {
	*kClient
}

func (p *kStockServiceClient) GetRealtime(ctx context.Context, req *stock.GetRealtimeRequest, callOptions ...callopt.Option) (r *stock.GetRealtimeResponse, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	return p.kClient.GetRealtime(ctx, req)
}

func (p *kStockServiceClient) GetFinancialReport(ctx context.Context, req *stock.GetFinancialReportRequest, callOptions ...callopt.Option) (r *stock.GetFinancialReportResponse, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	return p.kClient.GetFinancialReport(ctx, req)
}

func (p *kStockServiceClient) GetMarketSectors(ctx context.Context, req *stock.GetMarketSectorsRequest, callOptions ...callopt.Option) (r *stock.GetMarketSectorsResponse, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	return p.kClient.GetMarketSectors(ctx, req)
}

func (p *kStockServiceClient) GetLimitUpPool(ctx context.Context, req *stock.GetLimitUpPoolRequest, callOptions ...callopt.Option) (r *stock.GetLimitUpPoolResponse, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	return p.kClient.GetLimitUpPool(ctx, req)
}

func (p *kStockServiceClient) GetSectorStocks(ctx context.Context, req *stock.GetSectorStocksRequest, callOptions ...callopt.Option) (r *stock.GetSectorStocksResponse, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	return p.kClient.GetSectorStocks(ctx, req)
}

func (p *kStockServiceClient) GetDragonTigerList(ctx context.Context, req *stock.GetDragonTigerListRequest, callOptions ...callopt.Option) (r *stock.GetDragonTigerListResponse, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	return p.kClient.GetDragonTigerList(ctx, req)
}
`
	os.WriteFile("kitex_gen/stock/stockservice/client.go", []byte(stockClientContent), 0644)

	// 3. Overwrite stock/stockservice/server.go
	stockServerContent := `// Code generated by Kitex v1.20.0. DO NOT EDIT.
package stockservice

import (
	server "github.com/cloudwego/kitex/server"
	stock "stock_assistant/backend/stock_service/kitex_gen/stock"
)

// NewServer creates a server.Server with the given handler and options.
func NewServer(handler stock.StockService, opts ...server.Option) server.Server {
	var options []server.Option

	options = append(options, opts...)
	options = append(options, server.WithCompatibleMiddlewareForUnary())

	svr := server.NewServer(options...)
	if err := svr.RegisterService(serviceInfo(), handler); err != nil {
		panic(err)
	}
	return svr
}

func RegisterService(svr server.Server, handler stock.StockService, opts ...server.RegisterOption) error {
	return svr.RegisterService(serviceInfo(), handler, opts...)
}
`
	os.WriteFile("kitex_gen/stock/stockservice/server.go", []byte(stockServerContent), 0644)
}
