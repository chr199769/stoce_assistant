// Code generated by hertz generator.

package api

import (
	"context"
	"io"

	"stock_assistant/backend/ai_service/kitex_gen/ai"
	api "stock_assistant/backend/gateway/biz/model/api"
	"stock_assistant/backend/gateway/biz/rpc"
	"stock_assistant/backend/stock_service/kitex_gen/stock"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// GetRealtime .
// @router /api/stocks/:code/realtime [GET]
func GetRealtime(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetRealtimeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Call Stock Service
	rpcReq := &stock.GetRealtimeRequest{
		Code: req.Code,
	}
	rpcResp, err := rpc.StockClient.GetRealtime(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	// Map response
	resp := &api.RealtimeResponse{}
	if rpcResp.Stock != nil {
		resp.Code = rpcResp.Stock.Code
		resp.Name = rpcResp.Stock.Name
		resp.CurrentPrice = rpcResp.Stock.CurrentPrice
		resp.ChangePercent = rpcResp.Stock.ChangePercent
		resp.Volume = rpcResp.Stock.Volume
		resp.Timestamp = rpcResp.Stock.Timestamp
	}

	c.JSON(consts.StatusOK, resp)
}

// GetPrediction .
// @router /api/prediction/:code [POST]
func GetPrediction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.PredictionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Call AI Service
	rpcReq := &ai.GetPredictionRequest{
		Code:        req.Code,
		Days:        req.Days,
		IncludeNews: req.IncludeNews,
		Model:       req.Model,
	}
	rpcResp, err := rpc.AIClient.GetPrediction(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	if rpcResp.Result_ == nil {
		c.String(consts.StatusInternalServerError, "AI service returned empty result")
		return
	}

	resp := &api.PredictionResponse{
		Code:        rpcResp.Result_.Code,
		Confidence:  rpcResp.Result_.Confidence,
		Analysis:    rpcResp.Result_.Analysis,
		NewsSummary: rpcResp.Result_.NewsSummary_,
	}

	c.JSON(consts.StatusOK, resp)
}

// RecognizeStockImage .
// @router /api/image/recognize [POST]
func RecognizeStockImage(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.ImageRecognitionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Read image file
	fileHeader, err := c.FormFile("image")
	if err != nil {
		c.String(consts.StatusBadRequest, "Missing image file")
		return
	}

	file, err := fileHeader.Open()
	if err != nil {
		c.String(consts.StatusInternalServerError, "Failed to open image file")
		return
	}
	defer file.Close()

	fileBytes, err := io.ReadAll(file)
	if err != nil {
		c.String(consts.StatusInternalServerError, "Failed to read image file")
		return
	}

	model := c.PostForm("model")

	// Call AI Service
	rpcReq := &ai.ImageRecognitionRequest{
		ImageData: fileBytes,
		Model:     model,
	}

	hlog.Info("Calling AI Service for Image Recognition...")
	rpcResp, err := rpc.AIClient.ImageRecognition(ctx, rpcReq)
	if err != nil {
		hlog.Errorf("AI Service failed: %v", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	hlog.Info("AI Service returned successfully")

	// Map response
	resp := &api.ImageRecognitionResponse{
		Stocks: make([]*api.RecognizedStock, 0),
	}

	if rpcResp.Stocks != nil {
		for _, s := range rpcResp.Stocks {
			resp.Stocks = append(resp.Stocks, &api.RecognizedStock{
				Code: s.Code,
				Name: s.Name,
			})
		}
	}

	c.JSON(consts.StatusOK, resp)
}
