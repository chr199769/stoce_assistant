// Code generated by hertz generator.

package api

import (
	"context"
	"io"

	"stock_assistant/backend/gateway/kitex_gen/ai"
	api "stock_assistant/backend/gateway/biz/model/api"
	"stock_assistant/backend/gateway/biz/rpc"
	"stock_assistant/backend/gateway/kitex_gen/stock"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// GetRealtime .
// @router /api/stocks/:code/realtime [GET]
func GetRealtime(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetRealtimeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Call Stock Service
	rpcReq := &stock.GetRealtimeRequest{
		Code: req.Code,
	}
	rpcResp, err := rpc.StockClient.GetRealtime(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	// Map response
	resp := &api.RealtimeResponse{}
	if rpcResp.Stock != nil {
		resp.Code = rpcResp.Stock.Code
		resp.Name = rpcResp.Stock.Name
		resp.CurrentPrice = rpcResp.Stock.CurrentPrice
		resp.ChangePercent = rpcResp.Stock.ChangePercent
		resp.Volume = rpcResp.Stock.Volume
		resp.Timestamp = rpcResp.Stock.Timestamp
	}

	c.JSON(consts.StatusOK, resp)
}

// GetFinancialReport .
// @router /api/stocks/:code/financial [GET]
func GetFinancialReport(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetFinancialReportRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Call Stock Service
	rpcReq := &stock.GetFinancialReportRequest{
		Code: req.Code,
	}
	rpcResp, err := rpc.StockClient.GetFinancialReport(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	// Map response
	resp := &api.GetFinancialReportResponse{
		Reports: make([]*api.FinancialData, 0),
	}
	if rpcResp.Reports != nil {
		for _, r := range rpcResp.Reports {
			resp.Reports = append(resp.Reports, &api.FinancialData{
				ReportDate:   r.ReportDate,
				TotalRevenue: r.TotalRevenue,
				NetProfit:    r.NetProfit,
				Eps:          r.Eps,
				RevenueYoy:   r.RevenueYoy,
				ProfitYoy:    r.ProfitYoy,
			})
		}
	}

	c.JSON(consts.StatusOK, resp)
}

// GetPrediction .
// @router /api/prediction/:code [POST]
func GetPrediction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.PredictionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Call AI Service
	rpcReq := &ai.GetPredictionRequest{
		Code:        req.Code,
		Days:        req.Days,
		IncludeNews: req.IncludeNews,
		Model:       req.Model,
	}
	rpcResp, err := rpc.AIClient.GetPrediction(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	if rpcResp.Result_ == nil {
		c.String(consts.StatusInternalServerError, "AI service returned empty result")
		return
	}

	resp := &api.PredictionResponse{
		Code:        rpcResp.Result_.Code,
		Confidence:  rpcResp.Result_.Confidence,
		Analysis:    rpcResp.Result_.Analysis,
		NewsSummary: rpcResp.Result_.NewsSummary_,
	}

	c.JSON(consts.StatusOK, resp)
}

// RecognizeStockImage .
// @router /api/image/recognize [POST]
func RecognizeStockImage(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.ImageRecognitionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Read image file
	fileHeader, err := c.FormFile("image")
	if err != nil {
		c.String(consts.StatusBadRequest, "Missing image file")
		return
	}

	file, err := fileHeader.Open()
	if err != nil {
		c.String(consts.StatusInternalServerError, "Failed to open image file")
		return
	}
	defer file.Close()

	fileBytes, err := io.ReadAll(file)
	if err != nil {
		c.String(consts.StatusInternalServerError, "Failed to read image file")
		return
	}

	model := c.PostForm("model")

	// Call AI Service
	rpcReq := &ai.ImageRecognitionRequest{
		ImageData: fileBytes,
		Model:     model,
	}

	hlog.Info("Calling AI Service for Image Recognition...")
	rpcResp, err := rpc.AIClient.ImageRecognition(ctx, rpcReq)
	if err != nil {
		hlog.Errorf("AI Service failed: %v", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	hlog.Info("AI Service returned successfully")

	// Map response
	resp := &api.ImageRecognitionResponse{
		Stocks: make([]*api.RecognizedStock, 0),
	}

	if rpcResp.Stocks != nil {
		for _, s := range rpcResp.Stocks {
			resp.Stocks = append(resp.Stocks, &api.RecognizedStock{
				Code: s.Code,
				Name: s.Name,
			})
		}
	}

	c.JSON(consts.StatusOK, resp)
}

// MarketReview .
// @router /api/market/review [POST]
func MarketReview(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.MarketReviewRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Call AI Service
	rpcReq := &ai.MarketReviewRequest{
		Date:         req.Date,
		FocusSectors: req.FocusSectors,
	}

	rpcResp, err := rpc.AIClient.MarketReview(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	resp := &api.MarketReviewResponse{
		Summary:    rpcResp.Summary,
		Confidence: 0.85,     // Mock confidence as it's not in rpcResp yet
		Date:       req.Date, // Echo date
	}

	c.JSON(consts.StatusOK, resp)
}

// GetSectorStocks .
// @router /api/stock/sector/stocks [GET]
func GetSectorStocks(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetSectorStocksRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	rpcReq := &stock.GetSectorStocksRequest{
		SectorCode: req.SectorCode,
	}
	rpcResp, err := rpc.StockClient.GetSectorStocks(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	resp := &api.GetSectorStocksResponse{
		Stocks: make([]*api.SectorStockItem, 0),
	}
	if rpcResp.Stocks != nil {
		for _, s := range rpcResp.Stocks {
			resp.Stocks = append(resp.Stocks, &api.SectorStockItem{
				Code:          s.Code,
				Name:          s.Name,
				Price:         s.Price,
				ChangePercent: s.ChangePercent,
				Volume:        s.Volume,
				Amount:        s.Amount,
				MarketCap:     s.MarketCap,
			})
		}
	}

	c.JSON(consts.StatusOK, resp)
}

// GetDragonTigerList .
// @router /api/stock/dragontiger/list [GET]
func GetDragonTigerList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetDragonTigerListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	rpcReq := &stock.GetDragonTigerListRequest{
		Date: req.Date,
	}
	rpcResp, err := rpc.StockClient.GetDragonTigerList(ctx, rpcReq)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	resp := &api.GetDragonTigerListResponse{
		Items: make([]*api.DragonTigerItem, 0),
	}

	if rpcResp.Items != nil {
		for _, item := range rpcResp.Items {
			// Map Seats
			buySeats := make([]*api.DragonTigerSeat, 0)
			for _, bs := range item.BuySeats {
				buySeats = append(buySeats, &api.DragonTigerSeat{
					Name:    bs.Name,
					BuyAmt:  bs.BuyAmt,
					SellAmt: bs.SellAmt,
					NetAmt:  bs.NetAmt,
					Tags:    bs.Tags,
				})
			}
			sellSeats := make([]*api.DragonTigerSeat, 0)
			for _, ss := range item.SellSeats {
				sellSeats = append(sellSeats, &api.DragonTigerSeat{
					Name:    ss.Name,
					BuyAmt:  ss.BuyAmt,
					SellAmt: ss.SellAmt,
					NetAmt:  ss.NetAmt,
					Tags:    ss.Tags,
				})
			}

			resp.Items = append(resp.Items, &api.DragonTigerItem{
				Code:          item.Code,
				Name:          item.Name,
				ClosePrice:    item.ClosePrice,
				ChangePercent: item.ChangePercent,
				Reason:        item.Reason,
				NetInflow:     item.NetInflow,
				BuySeats:      buySeats,
				SellSeats:     sellSeats,
			})
		}
	}

	c.JSON(consts.StatusOK, resp)
}
